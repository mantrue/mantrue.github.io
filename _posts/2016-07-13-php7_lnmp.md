---
layout: post
title: php7 lnmp+swoole+workerman+redis安装
author: 承鹏辉
category: linux
---

```
闲来无事  动手测试下swoole和workerman的性能  突然想到用php7是不是更爽,教程本不应该存在的东西
因为网上太多的安装教程  一键安装  rpm安装  考虑到有的同学可能喜欢编译安装 就出了这个教程
但是还是不应该存在的东西 因为我们没必要重复的造轮子 
主要是会配置环境 这就像编码 你说是自己开发简单还是修改别人的简单 技术决定思维的结果
安装没有按顺序的 想到什么就安装什么了
博文都是原创  复制请谨慎
```

### 安装需要的库
```
首先安装各种库吧 如果不安装也没事的 
linux系统很智能 安装软件的时候会提示并报错的 根据错误安装对应的库即可
yum install -y gcc gcc-c++ autoconf libjpeg libjpeg-devel enchant-devel pam-devel libc-client libc-client-devel libpng libpng-devel freetype freetype-devel libpng libpng-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses curl openssl-devel gdbm-devel db4-devel libXpm-devel libX11-devel gd-devel gmp-devel readline-devel libxslt-devel expat-devel xmlrpc-c xmlrpc-c-devel
```


### 安装libmcrypt库

```
wget ftp://mcrypt.hellug.gr/pub/crypto/mcrypt/libmcrypt/libmcrypt-2.5.7.tar.gz
tar zxf libmcrypt-2.5.7.tar.gz
cd libmcrypt-2.5.7
./configure
make && make install
```

### 安装php7

```
下载php7
tar -zxvf 进行解压
cd 进入php7目录 名字用解压后的和自己重新起都可以的
执行
./configure  --prefix=/usr/local/php7/  --with-config-file-path=/usr/local/php7/etc  --with-config-file-scan-dir=/usr/local/php7/etc/conf.d  --enable-fpm  --with-fpm-user=web  --with-fpm-group=www  --enable-soap  --with-openssl  --with-openssl-dir  --with-mcrypt  --with-pcre-regex  --with-zlib  --with-iconv  --with-bz2  --enable-calendar  --with-curl  --with-cdb  --enable-dom  --enable-exif  --with-pcre-dir  --enable-ftp  --with-gd  --with-jpeg-dir  --with-png-dir  --with-freetype-dir  --with-gettext  --with-gmp  --with-mhash  --enable-mbstring  --with-libmbfl  --with-onig  --enable-pdo  --with-pdo-mysql  --with-zlib-dir  --with-readline  --enable-session  --enable-shmop  --enable-simplexml  --enable-sockets  --enable-sysvmsg  --enable-sysvsem  --enable-sysvshm  --enable-wddx  --with-libxml-dir  --with-xsl  --enable-zip  --enable-mysqlnd  --with-mysqli  --without-pear
make && make install

在源安装文件下有这个文件 移动
cp php.ini-production /usr/local/php7/etc/php.ini

重新命名fpm.conf
cp /usr/local/php7/etc/php-fpm.conf.default /usr/local/php7/etc/php-fpm.conf

fpm扩展配置文件
cp /usr/local/php7/etc/php-fpm.d/www.conf.default www.conf

vim配置php-fpm.conf  include选项
把include路径设置为加载  www.conf的目录  一般不用改动

如果你听不懂我说的什么  那下面的就不用看了 谢谢

接下来执行
执行php-fpm命令 cd php目录下的sbin目录直接执行即可
ps aux | grep php 即可看到fpm进程

那怎么杀死它呢

pkill php-fpm结束进程 即可

将php编译生成的bin目录添加到当前Linux系统的环境变量中
echo -e '\nexport PATH=/usr/local/php7/bin:/usr/local/php7/sbin:$PATH\n' >> /etc/profile && source /etc/profile

好php 安装完毕

```

### 编译pcntl扩展  为下面运行wokerman做准备 (pcntl为操作进程准备的)

```
先去ext扩展目录  进入pcntl目录  (ext目录就是你的php源文件目录下的目录。。。。。)
执行
phpize
./configure
make && make install安装
完事后生成编译后的扩展存放目录  记下来
vim php.ini
添加 
extension_dir =  "/usr/local/php7/lib/php/extensions/no-debug-non-zts-20151012/"
extension=pcntl.so

kill掉fpm进程  重启  
php -m查看即可

```

### 编译nginx

```
yum -y install pcre*
yum -y install openssl*
wget http://nginx.org/download/nginx-1.7.8.tar.gz
tar -zxvf nginx-1.7.8.tar.gz
cd nginx-1.7.8
./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-http_spdy_module --with-http_stub_status_module --with-pcre
make
make install
添加这样一条开放80端口的规则后保存
vim /etc/sysconfig/iptables
-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT
./usr/local/nginx/sbin/nginx 执行nginx命令
vim /usr/local/nginx/conf/nginx.conf 配置nginx
添加include 虚拟主机配置目录 /usr/local/nginx/vhost/default.com.conf
创建mkdir vhost vim default.com.conf 配置
server
  {
   listen       80;
   server_name  localhost;
   index index.php index.html index.htm;
   root  /usr/local/nginx/html;

 location / {

        if (!-e $request_filename){
          rewrite ^(.*)$ /index.php?s=/$1 last;
          rewrite ^(.*)$ /index.php/$1 last;
         }
        }
    location ~ .*\.(php|php5)
    {
           fastcgi_pass  127.0.0.1:9000;
           fastcgi_index index.php;
           include fastcgi.conf;
        }

    location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$
    {
      expires      30d;
    }
    location ~ .*\.(js|css)?$
    {
      expires      1h;
    }
autoindex on;
access_log  /usr/local/nginx/logs/default.logs;
}
重启nginx即可
进入/usr/local/nginx/html 创建index.php进行测试即可

这样nginx就把任务交给fpm进程来处理了。
访问即可看到你熟悉的画面

```

### 安装redis

```
wget http://download.redis.io/redis-stable.tar.gz
tar xvzf redis-stable.tar.gz
cd redis-stable
make
cd src 下 执行 
mkdir /usr/local/redis
cp redis-server /usr/local/redis/
cp redis-benchmark /usr/local/redis/
cp redis-cli /usr/local/redis/
cp redis.conf /usr/local/redis/

配置redis.conf   把daemonize设置为yes(这样redis就可以以守护进程的方式运行了)

启动redis
./redis-server  redis.conf
ps aux | grep redis   查看  进程是否正常启动

```

### swoole和workerman可以干什么

```
这个需要有点网络的基础的 这样会更明白些的
socket api  封装了tcp/ip的通讯接口
这些个框架利用这些通讯的接口封装成了框架
网络通讯框架  专注网络传输
可以干嘛？
理论上可以开发你想到的各种应用  包括服务器软件 都可以重写
都支持长链接 开发比如智能设备通讯 游戏后台服务器  聊天 异步 队列
github上有现成的代码  没事可以搜索下
php根据url访问 天生阻塞  想执行异步  各种通讯  那就是最好的选择
```

### 安装swoole扩展

```
官网下载swoole
cd swoole
phpize
./configure
make && make install
生成扩展目录  记得复制下 如果上面流程走过  就不用记下了。
去php.ini   设置
extension=swoole.so
然后重启fpm 
php -m 

测试：创建文件 webserver.php
<?php
//创建websocket服务器对象，监听0.0.0.0:9502端口
$ws = new swoole_websocket_server("0.0.0.0", 9502);

$ws->set(array(
    'worker_num' => 4,   //工作进程数量
    'daemonize' => true, //是否作为守护进程
));

//监听WebSocket连接打开事件
$ws->on('open', function ($ws, $request) {
    var_dump($request->fd, $request->get, $request->server);
    $ws->push($request->fd, "hello, welcome\n");
});

//监听WebSocket消息事件
$ws->on('message', function ($ws, $frame) {
    echo "Message: {$frame->data}\n";
    $ws->push($frame->fd, "server: {$frame->data}");
});

//监听WebSocket连接关闭事件
$ws->on('close', function ($ws, $fd) {
    echo "client-{$fd} is closed\n";
});

$ws->start();

cli 写直接运行该文件  我已经开启守护进程了 好了现在你打开你的浏览器  控制台直接用websocket对象进程链接把

```
应用案例

* <a href="https://github.com/lchb369/swooleIM" target="_blank">基于swooleIM</a>
* <a href="https://github.com/james-rh/swoole_pushmsg_websocket" target="_blank">基于swoole推送</a>
* <a href="https://github.com/hsinlu/swoole-chatroom" target="_blank">基于swooleIM</a>

### 安装workerman

```
curl -Ss http://www.workerman.net/check.php | php 检查安装需要的扩展  没有就按照上面的编译安装即可
把workerman下载复制到任何目录  然后编写入口文件运行即可

workerman的运行不依赖任何的容器
测试：创建文件 webserver.php
<?php
use Workerman\Worker;
require_once './Workerman/Autoloader.php';

// 创建一个Worker监听2346端口，使用websocket协议通讯
$ws_worker = new Worker("websocket://0.0.0.0:2346");

// 启动4个进程对外提供服务
$ws_worker->count = 4;

// 当收到客户端发来的数据后返回hello $data给客户端
$ws_worker->onMessage = function($connection, $data)
{
    // 向客户端发送hello $data
    $connection->send('hello ' . $data);
};

// 运行worker
Worker::runAll();
cli 写直接运行该文件  我已经开启守护进程了 好了现在你打开你的浏览器  控制台直接用websocket对象进程链接把

```
应用案例

* <a href="https://github.com/walkor/workerman-queue" target="_blank">基于workerman队列</a>
* <a href="https://github.com/walkor/gatewayworker" target="_blank">基于workerman多设备通讯</a>

### 为swoole+workerman websocket压力测试

```
用的ab工具  没有自己装
ab -n1000000 -c100 -k http://127.0.0.1:9502/
ab -n1000000 -c100 -k http://127.0.0.1:2346/
性能都差不多
不过后期swoole更好一些的表现
可能php还是动态的有消耗吧

```


### 安装boost库为安装最新版的mysql做准备 也可以设置参数自己下载

```
	
 ./bootstrap.sh --prefix=/usr/local/boost  安装目录自己设定
 ./b2 install
 ok
 
```
 
### 安装mysql

```
官网下载最新版的mysql
解压
进入mysql目录
执行
 cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/usr/local/mysql/data -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DMYSQL_TCP_PORT=3306 -DMYSQL_USER=mysql -DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_ARCHIVE_STORAGE_ENGINE=1 -DWITH_BLACKHOLE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 -DDOWNLOAD_BOOST=1 -DWITH_BOOST=/usr/local/boost

```

@承鹏辉