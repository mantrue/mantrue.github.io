---
layout: post
title: MySQL SQL语句优化
author: 承鹏辉
category: mysql
---

```
网上自己复制  修改内容 了解优化过程

```

EXPLAIN显示了MySQL如何使用索引来处理SELECT语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。

使用方法，在select语句前加上`EXPLAIN`就可以了：

如：

```sql
EXPLAIN SELECT `surname`,`first_name` FORM `a`,`b` WHERE `a`.`id`=`b`.`id` 
```

**EXPLAIN**列的解释：

|  列  |  描述  |
| ---- | ---- |
| `table` | 显示这一行的数据是关于哪张表的。|
| `type` | 这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为 `const`、`eq_reg`、`ref`、`range`、`index`和`ALL`。 |
| `possible_keys` | 显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从`WHERE`语句中选择一个合适的语句。 | 
| `key` |  实际使用的索引。如果为`NULL`，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在`SELECT`语句中使用`USE INDEX（indexname）` 来强制使用一个索引或者用`IGNORE INDEX（indexname）`来强制MySQL忽略索引。 |
| `key_len` | 使用的索引的长度。在不损失精确性的情况下，长度越短越好。  |
| `ref` | 显示索引的哪一列被使用了，如果可能的话，是一个常数。 | 
| `rows` | MySQL认为必须检查的用来返回请求数据的行数。 |
| `Extra` | 关于MySQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是`Using temporary`和`Using filesort`，意思MySQL根本不能使用索引，结果是检索会很慢。  |

**type列返回的描述的意义：**

| ---- | ---- |
| `system` | 表仅有一行(=系统表)。这是 const 连接类型的一个特例。|
| `const` | const 用于用常数值比较 PRIMARY KEY 时。当 查询的表仅有一行时,使用 System。|
| `eq_ref` | const 用于用常数值比较 PRIMARY KEY 时。当 查询的表仅有一行时,使用 System。|
| `ref` | 连接不能基于关键字选择单个行,可能查找 到多个符合条件的行。 叫做 ref 是因为索引要 跟某个参考值相比较。这个参考值或者是一 个常数,或者是来自一个表里的多表查询的 结果值。|
| `ref_or_null` | 如同 ref, 但是 MySQL 必须在初次查找的结果 里找出 null 条目,然后进行二次查找。|
| `index_merge` | 说明索引合并优化被使用了。|
| `unique_subquery` | 在某些 IN 查询中使用此种类型,而不是常规的 ref:value IN (SELECT primary_key FROM single_table WHERE some_expr)。|
| `index_subquery` | 在 某 些 IN 查 询 中 使 用 此 种 类 型 , 与 unique_subquery 类似,但是查询的是非唯一 性索引: value IN (SELECT key_column FROM single_table WHERE some_expr)。|
| `range` | 只检索给定范围的行,使用一个索引来选择 行。key 列显示使用了哪个索引。当使用=、 <>、>、>=、<、<=、IS NULL、<=>、BETWEEN 或者 IN 操作符,用常量比较关键字列时,可 以使用 range。|
| `index` | 全表扫描,只是扫描表的时候按照索引次序 进行而不是行。主要优点就是避免了排序, 但是开销仍然非常大。|
| `all` | 最坏的情况,从头到尾全表扫描。|

**extra列返回的描述的意义：**

| 值 | 意义 |
| ---- | ---- |
| `Distinct` | 一旦MySQL找到了与行相联合匹配的行，就不再搜索了。 |
| `Not exists` | MySQL优化了`LEFT JOIN`，一旦它找到了匹配`LEFT JOIN`标准的行，就不再搜索了。| 
| `Range checked for each Record（index map:#）` | 没有找到理想的索引，因此对于从前面表中来的每一个行组合，MySQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一。|
| `Using filesort` | 看到这个的时候，查询就需要优化了。MySQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行。|
| `Using index` | 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候。|
| `Using temporary` | 看到这个的时候，查询需要优化了。这里，MySQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行`ORDER BY`上，而不是`GROUP BY`上。 |
| `Where used` | 使用了`WHERE`从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型`ALL`或`index`，这就会发生，或者是查询有问题不同连接类型的解释（按照效率高低的顺序排序）。 |
| `system` | 表只有一行 `system` 表。这是const连接类型的特殊情况 。 |
| `const` | 表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，因为MySQL先读这个值然后把它当做常数来对待。 |
| `eq_ref` | 在连接中，MySQL在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用。|
| `ref` | 这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好。|
| `range` | 这个连接类型使用索引返回一个范围中的行，比如使用>或<查找东西时发生的情况。|
| `index` | 这个连接类型对前面的表中的每一个记录联合进行完全扫描（比`ALL`更好，因为索引一般小于表数据）。|
| `ALL` | 这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免。 | 

一般的分页limit 后跟order by排序下,确定加上索引,不让扫描全表

### 个人随笔

```
安静的等待,你若盛开,蝴蝶自来

承接高质量 网站开发 app开发 如有需要请点击About联系

```